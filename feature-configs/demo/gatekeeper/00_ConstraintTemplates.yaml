#################################################################################################
# Original rego taken from the stackrox blog post and corresponding github repo here:           #
# - https://www.openshift.com/blog/better-kubernetes-security-with-open-policy-agent-opa-part-2 #
# - https://github.com/stackrox/blog-examples/tree/master/code/opa-gatekeeper-taint-tolerations #
#################################################################################################
---
# Part One -- Restrict Global Toleration
#
# This blocks a toleration such as:
# oc -n foo get pod/bar -o yaml
#
#   ...
#     spec:
#       tolerations:
#       - operator: Exists
#

apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srestrictglobaltoleration
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictGlobalToleration
      validation:
        openAPIV3Schema:
          properties:
            allowGlobalToleration:
              type: boolean
          required:
          - allowGlobalToleration

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srestrictglobaltoleration
        # Global assignments
        pod := input.review.object
        tolerations := pod.spec.tolerations

        # A toleration with no key matches all taints
        global_tolerations := [key | k := object.get(tolerations[_], "key", "")
                                     k == ""
                                     key := k]

        # v- taken from upstream; but should not be necessary since our APIv3 schema
        # controls the possible values we can receive.
        default allow_global = false
        allow_global {
          input.parameters.allowGlobalToleration == true
        }

        # Fail if global toleration exists and we disallow global tolerations for
        # this taint
        violation[{"msg": msg}] {
          count(global_tolerations) > 0
          not allow_global
          msg := sprintf("Global tolerations not allowed: %v", [tolerations])
        }


---
# Part Two -- Restrict Specific Toleration
#
# This blocks a toleration such as:
# oc -n foo get pod/bar -o yaml
#
#   ...
#     spec:
#       tolerations:
#       - effect: NoSchedule
#         key: node-role.kubernetes.io/master
#         operator: Exists

#
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srestrictspecifictoleration
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictSpecificToleration
      validation:
        openAPIV3Schema:
          properties:
            restrictedTaint:
              type: object
              properties:
                key:
                  type: string
                value:
                  type: string
                effect:
                  type: string
              required:
              - key
              - value
              - effect
          required:
          - restrictedTaint
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srestrictspecifictoleration
        # Global assignments
        pod := input.review.object
        tolerations := pod.spec.tolerations
        taint := input.parameters.restrictedTaint

        # This comprehension creates an array with an entry for
        # each matching toleration in the tolerations array
        matching_tolerations := [match | match := toleration_match(tolerations[_])]

        # Fail if matching toleration exists
        violation[{"msg": msg}] {
          count(matching_tolerations) > 0
          msg := sprintf("Toleration is not allowed for taint %v", [taint])
        }

        # Functions to test if pod toleration matches the taint
        toleration_match(toleration) {
          key := object.get(toleration, "key", "")
          key == taint.key
          effect := object.get(toleration, "effect", "")
          effect_check(effect)
          operator := object.get(toleration, "operator", "Equal")
          operator_check(toleration, operator)
        }

        # Functions can be defined multiple times, matching against non-variable args
        # This acts as a conditional
        # If effect is empty, match any
        effect_check("") {
          true
        }

        # Otherwise, specific effect must match
        effect_check(effect) {
          effect == taint.effect
        }

        # When the toleration operator is "Equal" we need to match value fields
        operator_check(toleration, "Equal") {
          value := object.get(toleration, "value", "")
          value == taint.value
        }

        # When the toleration operator is "Exists", the match is always true
        # because we already matched on key and effect
        operator_check(toleration, "Exists") {
          true
        }


